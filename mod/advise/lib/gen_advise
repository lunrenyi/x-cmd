# shellcheck shell=sh disable=SC3043,2120,2181,1091,2016,2034,2012
# ___X_CMD_ADVISE_GEN_ADVISE_INDEX_FIELDS='useparam

___X_CMD_ADVISE_GEN_ADV_ERREXIT="${___X_CMD_UNSEENCHAR_001}${___X_CMD_UNSEENCHAR_002}${___X_CMD_UNSEENCHAR_003}"
# useparam,name,synopsis,desc,exec,tldr,other,setup,tip,demo,subcmd,option,flag,[0-9]+,n
___x_cmd_advise_gen_advise(){
    local op="$1"
    case "$op" in
        useparam|exec|parse_adv_data|merge_awk)
           shift; ___x_cmd_advise_gen_advise__"$op" "$@" ;;
        *) ___x_cmd_advise_gen_advise__main "$@" ;;
    esac
}

___x_cmd_advise_gen_advise__useparam()(
    local mod_name="$1"
    local mod_path="$2"
    [ -n "$mod_name" ] || N=advise M="Please provide mod name" log:ret:64
    [ -d "$mod_path" ] || N=advise M="Unexisted directory of path. [path=$mod_path]" log:ret:64
    xrc:mod "$mod_name/latest" || return 1
    local main_func; main_func="$___X_CMD_XRC_SET_MAIN"
    [ "$main_func" != "${main_func%"$mod_name"}" ] || main_func="___x_cmd_$mod_name"
    ___x_cmd hascmd "$main_func" || {
        advise:error "Not found set main function of $mod_name"
        return 1
    }

    xrc reload "$mod_name"
    advise:debug "Useparam - X_CMD_ADVISE_FUNC_NAME=$main_func $main_func _x_cmd_advise_json"
    X_CMD_ADVISE_FUNC_NAME="$main_func" "$main_func" _x_cmd_advise_json
)

___x_cmd_advise_gen_advise__exec()(
    local mod_path="$1"
    [ -d "$mod_path" ] || N=advise M="Unexisted directory of path. [path=$mod_path]" log:ret:64
    shift
    ___x_cmd_cmds_cd "$mod_path" || return 1
    log:sub:init  -i gen_advise advise 'Executing'
    local cmd; printf "%s\n" "$*" | ___x_cmd jo env .\* cmd=. -- '
    advise:warn "cmd - $cmd"
    ___x_cmd_evex "$cmd" 2>/dev/null || {
        advise:error "Fail to exec - $cmd"
        printf "%s\n" "$___X_CMD_ADVISE_GEN_ADV_ERREXIT"
        exit 1
    }
'
    log:sub:fini
)

___x_cmd_advise_gen_advise__parse_adv_data(){
    local build_dev=
    case "$1" in
        --dev) build_dev=1; shift ;;
    esac

    local mod_name="$1"
    local mod_path="$2"
    [ -n "$mod_name" ] || N=advise M="Please provide mod name" log:ret:64
    [ -d "$mod_path" ] || N=advise M="Unexisted directory of path. [path=$mod_path]" log:ret:64
    local adv_data="$mod_path/adv/data"
    local res_data="$___X_CMD_ROOT_ADV/$mod_name/data"
    local res_cookbook="$___X_CMD_ROOT_CODE/cookbook/mod/$mod_name"
    [ -d "$adv_data" ] || return 0
    ___x_cmd rmrf "$res_data" "$res_cookbook"

    ___x_cmd_cmds find "$adv_data" -type f | while read -r datafile; do
        tagfile="${datafile#*"$adv_data/"}"
        [ "$tagfile" != "$datafile" ] || continue
        [ -f "$datafile" ] || continue
        case "$datafile" in
            *.yml)
                    ___x_cmd ensurefp "$res_data/${tagfile%.yml*}.jso"
                    advise:debug "Generate $mod_name data/${tagfile%.yml*}.jso from adv/data/$tagfile"
                    < "$datafile" ___x_cmd scotty yml y2j | ___x_cmd_advise_gen_advise__merge_awk "$build_dev" > "$res_data/${tagfile%.yml*}.jso"
                    ;;
            */desc.*md)
                    [ -n "$build_dev" ] || {
                        advise:debug "Not supported in normal mode ==> $datafile"
                        continue
                    }
                    ___x_cmd ensurefp "$res_data/$tagfile"
                    advise:info "Copy $datafile -> $res_data/$tagfile"
                    ___x_cmd_cmds_cp "$datafile" "$res_data/$tagfile"
                    ;;
            *)      [ -n "$build_dev" ] || {
                        advise:debug "Not supported in normal mode ==> $datafile"
                        continue
                    }
                    tagfile="$res_cookbook/$tagfile"
                    ___x_cmd ensurefp "$tagfile"
                    advise:info "Copy $datafile -> $tagfile"
                    ___x_cmd cp "$datafile" "$tagfile"
                    ;;
        esac
    done
}

___x_cmd_advise_gen_advise__merge_awk(){
    local X_CMD_ADVISE_FILTER_FIELD=
    [ -n "$1" ] || X_CMD_ADVISE_FILTER_FIELD="case
web
abstract"

    X_CMD_ADVISE_FILTER_FIELD="$X_CMD_ADVISE_FILTER_FIELD" \
    ___x_cmd_cmds_awk \
    -v X_CMD_ADVISE_ERREXIT="$___X_CMD_ADVISE_GEN_ADV_ERREXIT" \
    -f "$___X_CMD_ROOT_MOD/awk/lib/core.awk"    \
    -f "$___X_CMD_ROOT_MOD/awk/lib/j/json.awk"  \
    -f "$___X_CMD_ROOT_MOD/awk/lib/j/jiter.awk" \
    -f "$___X_CMD_ROOT_MOD/awk/lib/j/jcp.awk"   \
    -f "$___X_CMD_ROOT_MOD/advise/lib/awk/gen.advise/build_merge.awk"
}

___x_cmd_advise_gen_advise__main(){
    local build_dev=
    case "$1" in
        --dev) build_dev=1; shift ;;
    esac

    local mod_name="$1"
    local mod_path="$2"
    [ -n "$mod_name" ] || N=advise M="Please provide mod name" log:ret:64
    [ -d "$mod_path" ] || N=advise M="Unexisted directory of path. [path=$mod_path]" log:ret:64

    local adv_dir="$mod_path/adv"
    local index_yml="$adv_dir/index.yml"

    [ -f "$index_yml" ] || N=advise M="Not found $adv_dir/index.yml" log:ret:64

    local resource;             resource="$___X_CMD_ROOT_ADV/$mod_name";
    ___x_cmd rmrf "$resource";  ___x_cmd mkdirp "$resource"

    # parse adv/data dir
    ___x_cmd_advise_gen_advise__parse_adv_data ${build_dev:+"--dev"} "$mod_name" "$mod_path" || return $?

    # parse adv/index.yml
    < "$index_yml" ___x_cmd scotty yml y2j | {
        local content;      content="$(___x_cmd_cmds_cat)"
        printf "%s\n" "$content"

        local useparam;     local setup;    local jsonfile
        printf "%s\n" "$content" | { ___x_cmd jo env . "useparam=.<useparam>" "setup=.<setup>"
            [ -z "$setup" ] || ___x_cmd_advise_gen_advise__exec "$mod_path" "$setup" || return 1

            ___x_cmd_cmds find "$adv_dir" -maxdepth 1 -name '*.json' | while read -r jsonfile; do
                advise:debug "Merge $jsonfile"
                ___x_cmd_cmds_cat "$jsonfile"; printf "\n"
            done

            if [ "$useparam" != "true" ]; then
                printf "%s\n" "{}"
            else
                ___x_cmd_advise_gen_advise__useparam "$mod_name" "$mod_path"
                [ "$?" = 0 ] || printf "%s\n" "$___X_CMD_ADVISE_GEN_ADV_ERREXIT"
            fi
        }
    } | ___x_cmd_advise_gen_advise__merge_awk "$build_dev" > "$resource/advise.jso"
    local exit_code="$?"

    if [ "$exit_code" -eq 0 ]; then
        advise:info "Success generate $mod_name advise.jso"
        return 0
    else
        ___x_cmd rmrf "$resource"
        advise:error "Fail to generate $mod_name advise.jso"
        return 1
    fi
}
